init = init_values,
iter = iter_num,
chains = chain_num,
warmup = warmup_num,
cores = core_num,
refresh = 100,
save_warmup = F,
init_r = 1,
control = list(
adapt_delta = adapt_delta,
stepsize = stepsize,
max_treedepth = max_treedepth
)
)
stan_fit = rstan::stan(
file = 'mm.stan',
data = stan_data,
seed = 1,
sample_file = save_model_file,
init = init_values,
iter = iter_num,
chains = chain_num,
warmup = warmup_num,
cores = core_num,
refresh = 100,
save_warmup = F,
init_r = 1,
control = list(
adapt_delta = adapt_delta,
stepsize = stepsize,
max_treedepth = max_treedepth
)
)
getStanData = function(beta = character(0),
deltaM_value = NULL,
binary_value = NULL,
ar_value = NULL,
random_value = NULL,
deltaD_value = NULL,
option_num = 3 * 2 + 1,
format_data) {
## memory model
if (min(format_data$sID) < 1 |
length(unique(format_data$sID)) != max(format_data$sID)) {
stop(
'Participant ID should start from 1, and be consecutive; otherwise it will cause error when sampling'
)
}
if (min(format_data$qID) < 1 |
length(unique(format_data$qID)) != max(format_data$qID)) {
stop(
'Question ID should start from 1, and be consecutive; otherwise it will cause error when sampling'
)
}
format_data = dplyr::arrange(format_data, qID, sID, tNo)
for (i in 2:nrow(format_data)) {
if ((format_data$sID[i] == format_data$sID[i - 1] &
format_data$tNo[i] != format_data$tNo[i - 1] + 1) |
(format_data$sID[i] != format_data$sID[i - 1] &
format_data$tNo[i] != 1)) {
stop('wrong thought index')
}
}
# feature matrix
if (length(beta > 0)) {
X = getFeatureMatrices(beta, format_data, deltaM_value,
option_num, print_names = F)
} else{
X = replicate(nrow(format_data), matrix(0, option_num, 0), simplify = FALSE)
}
## decision model
rating = as.numeric(as.character(format_data$rating))
rating_y = c()
rating_n = c()
if (!is.null(binary_value)){
if(binary_value == 1){
# make ratings binary for binary_value = 1
rating = sign(rating)
}
if (ar_value == 0){
rating_n = pmin(0, rating);
rating_y = pmax(0, rating);
} else{
rating_y = rating;
rating_n = rating;
}
if (deltaD_value == 1) {
for (n in 1:length(rating)) {
if (format_data$tNo[n] > 1) {
rating[n] = rating[n-1] + rating[n]
rating_n[n] = rating_n[n-1] + rating_n[n]
rating_y[n] = rating_y[n-1] + rating_y[n]
}
}
}
}
terminate = as.numeric(as.character(format_data$terminate))
stan_data <- list(
deltaM_value = deltaM_value,
condition_value = ifelse(is.null(format_data$condition), 0, 1),
C = option_num,
MC = (C + 1)/2,
# cluster numberss for one of the options
N = nrow(format_data),
K = length(beta),
S = length(unique(format_data$sID)),
# unique participant numbers
Q = length(unique(format_data$qID)),
# unique participant numbers
sID =  as.numeric(as.character(format_data$sID)),
# qID = rep(1,each=nrow(format_data)),##!! used fot testing no question differences
qID =  as.numeric(as.character(format_data$qID)),
tNo = as.numeric(as.character(format_data$tNo)),
cID = as.numeric(as.character(format_data$cID)),
X = X,
binary_value = binary_value,
ar_value = ar_value,
random_value = random_value,
deltaD_value = deltaD_value,
rating = rating,
rating_n = rating_n,
rating_y = rating_y,
terminate = terminate
)
if (!is.null(format_data$terminate)) {
stan_data$terminate = as.numeric(as.character(format_data$terminate))
}
return(stan_data)
}
## prepare inputs for RStan; getHMRStanData in 'model_functions.R'
stan_data = getStanData(
beta = beta,
deltaM_value = deltaM_value,
binary_value = binary_value,
ar_value = ar_value,
random_value = random_value,
deltaD_value = deltaD_value,
option_num = option_num,
format_data = format_data
)
getStanData = function(beta = character(0),
deltaM_value = NULL,
binary_value = NULL,
ar_value = NULL,
random_value = NULL,
deltaD_value = NULL,
option_num = 3 * 2 + 1,
format_data) {
## memory model
if (min(format_data$sID) < 1 |
length(unique(format_data$sID)) != max(format_data$sID)) {
stop(
'Participant ID should start from 1, and be consecutive; otherwise it will cause error when sampling'
)
}
if (min(format_data$qID) < 1 |
length(unique(format_data$qID)) != max(format_data$qID)) {
stop(
'Question ID should start from 1, and be consecutive; otherwise it will cause error when sampling'
)
}
format_data = dplyr::arrange(format_data, qID, sID, tNo)
for (i in 2:nrow(format_data)) {
if ((format_data$sID[i] == format_data$sID[i - 1] &
format_data$tNo[i] != format_data$tNo[i - 1] + 1) |
(format_data$sID[i] != format_data$sID[i - 1] &
format_data$tNo[i] != 1)) {
stop('wrong thought index')
}
}
# feature matrix
if (length(beta > 0)) {
X = getFeatureMatrices(beta, format_data, deltaM_value,
option_num, print_names = F)
} else{
X = replicate(nrow(format_data), matrix(0, option_num, 0), simplify = FALSE)
}
## decision model
rating = as.numeric(as.character(format_data$rating))
rating_y = c()
rating_n = c()
if (!is.null(binary_value)){
if(binary_value == 1){
# make ratings binary for binary_value = 1
rating = sign(rating)
}
if (ar_value == 0){
rating_n = pmin(0, rating);
rating_y = pmax(0, rating);
} else{
rating_y = rating;
rating_n = rating;
}
if (deltaD_value == 1) {
for (n in 1:length(rating)) {
if (format_data$tNo[n] > 1) {
rating[n] = rating[n-1] + rating[n]
rating_n[n] = rating_n[n-1] + rating_n[n]
rating_y[n] = rating_y[n-1] + rating_y[n]
}
}
}
}
terminate = as.numeric(as.character(format_data$terminate))
stan_data <- list(
deltaM_value = deltaM_value,
condition_value = ifelse(is.null(format_data$condition), 0, 1),
C = option_num,
MC = (option_num + 1)/2,
# cluster numberss for one of the options
N = nrow(format_data),
K = length(beta),
S = length(unique(format_data$sID)),
# unique participant numbers
Q = length(unique(format_data$qID)),
# unique participant numbers
sID =  as.numeric(as.character(format_data$sID)),
# qID = rep(1,each=nrow(format_data)),##!! used fot testing no question differences
qID =  as.numeric(as.character(format_data$qID)),
tNo = as.numeric(as.character(format_data$tNo)),
cID = as.numeric(as.character(format_data$cID)),
X = X,
binary_value = binary_value,
ar_value = ar_value,
random_value = random_value,
deltaD_value = deltaD_value,
rating = rating,
rating_n = rating_n,
rating_y = rating_y,
terminate = terminate
)
if (!is.null(format_data$terminate)) {
stan_data$terminate = as.numeric(as.character(format_data$terminate))
}
return(stan_data)
}
## prepare inputs for RStan; getHMRStanData in 'model_functions.R'
stan_data = getStanData(
beta = beta,
deltaM_value = deltaM_value,
binary_value = binary_value,
ar_value = ar_value,
random_value = random_value,
deltaD_value = deltaD_value,
option_num = option_num,
format_data = format_data
)
stan_data$MC
##fit model
stan_code = getStanCode(deltaM_value, deltaD_value, hier_value, random_value)
stan_fit = rstan::sampling(
stan_code,
data = stan_data,
seed = 1,
sample_file = save_model_file,
init = init_values,
iter = iter_num,
chains = chain_num,
warmup = warmup_num,
cores = core_num,
refresh = refresh,
save_warmup = save_warmup,
init_r = init_r,
control = list(
adapt_delta = adapt_delta,
stepsize = stepsize,
max_treedepth = max_treedepth
)
)
stan_fit = rstan::stan(
file = 'mm.stan',
data = stan_data,
seed = 1,
sample_file = save_model_file,
init = init_values,
iter = iter_num,
chains = chain_num,
warmup = warmup_num,
cores = core_num,
refresh = 100,
save_warmup = F,
init_r = 1,
control = list(
adapt_delta = adapt_delta,
stepsize = stepsize,
max_treedepth = max_treedepth
)
)
stan_fit = rstan::stan(
file = 'mm.stan',
data = stan_data,
seed = 1,
sample_file = save_model_file,
init = init_values,
iter = iter_num,
chains = chain_num,
warmup = warmup_num,
cores = core_num,
refresh = 100,
save_warmup = F,
init_r = 1,
control = list(
adapt_delta = adapt_delta,
stepsize = stepsize,
max_treedepth = max_treedepth
)
)
stan_fit = rstan::stan(
file = 'mm.stan',
data = stan_data,
seed = 1,
# sample_file = save_model_file,
init = init_values,
iter = iter_num,
chains = chain_num,
warmup = warmup_num,
cores = core_num,
refresh = 100,
save_warmup = F,
init_r = 1,
control = list(
adapt_delta = adapt_delta,
stepsize = stepsize,
max_treedepth = max_treedepth
)
)
stan_fit = rstan::stan(
file = 'mm.stan',
data = stan_data,
seed = 1,
# sample_file = save_model_file,
# init = init_values,
iter = iter_num,
chains = chain_num,
warmup = warmup_num,
cores = core_num,
refresh = 100,
save_warmup = F,
init_r = 1,
control = list(
adapt_delta = adapt_delta,
stepsize = stepsize,
max_treedepth = max_treedepth
)
)
stan_fit = rstan::stan(
file = 'mm.stan',
data = stan_data,
seed = 1,
# sample_file = save_model_file,
# init = init_values,
iter = 20,
chains = 1,
warmup = 2,
cores = 1,
refresh = 100,
save_warmup = F,
init_r = 1,
)
stan_fit = rstan::stan(
file = 'mm.stan',
data = stan_data,
seed = 1,
# sample_file = save_model_file,
# init = init_values,
iter = 20,
chains = 1,
warmup = 2,
cores = 1,
refresh = 100,
save_warmup = F,
init_r = 1
)
stan_data_fit = list(
stan_data = stan_data,
stan_fit = stan_fit
)
getPara(para_name = 'theta', stan_data_fit)
length(c(0.025,0.05,0.1,0.2,0.25,0.5,0.75,0.8,0.9,0.95,0.975))
#' \code{getPara} Parameter mean, quantiles and sd
#' and save the results to a .csv file when \code{csv_name} is specified
#'
#' @param para_name parameter to extract
#' @param quantiles quantiles to extract
#' @inheritParams getParaSummary
#'
#' @return A dataframe with parameter mean, quantiles and sd, can be saved to a csv file
#'
#'#' @export
getPara = function(para_name, stan_data_fit, csv_name,
quantiles = c(0.025,0.05,0.1,0.2,0.25,0.5,0.75,0.8,0.9,0.95,0.975)){
pp_all = as.data.frame(rstan::extract(stan_data_fit$stan_fit,pars=para_name))
temp = lapply(1:ncol(pp_all),function(x){quantile(pp_all[,x],quantiles)})
pp_all1 = rbind(colMeans(pp_all),do.call(cbind,temp),sapply(pp_all,sd))
colnames(pp_all1) = colnames(pp_all)
rownames(pp_all1)[1] = 'mean'
rownames(pp_all1)[2 + length(quantiles)] = 'sd'
if (!is.null(csv_name)) {
write.table(
pp_all1,
csv_name,
sep = ",",
append = FALSE,
quote = FALSE,
col.names = NA,
row.names = TRUE
)
}
return(pp_all1)
}
getPara(para_name = 'theta', stan_data_fit)
getPara
#' \code{getPara} Parameter mean, quantiles and sd
#' and save the results to a .csv file when \code{csv_name} is specified
#'
#' @param para_name parameter to extract
#' @param quantiles quantiles to extract
#' @inheritParams getParaSummary
#'
#' @return A dataframe with parameter mean, quantiles and sd, can be saved to a csv file
#'
#'#' @export
getPara = function(para_name, stan_data_fit, csv_name = NULL,
quantiles = c(0.025,0.05,0.1,0.2,0.25,0.5,0.75,0.8,0.9,0.95,0.975)){
pp_all = as.data.frame(rstan::extract(stan_data_fit$stan_fit,pars=para_name))
temp = lapply(1:ncol(pp_all),function(x){quantile(pp_all[,x],quantiles)})
pp_all1 = rbind(colMeans(pp_all),do.call(cbind,temp),sapply(pp_all,sd))
colnames(pp_all1) = colnames(pp_all)
rownames(pp_all1)[1] = 'mean'
rownames(pp_all1)[2 + length(quantiles)] = 'sd'
if (!is.null(csv_name)) {
write.table(
pp_all1,
csv_name,
sep = ",",
append = FALSE,
quote = FALSE,
col.names = NA,
row.names = TRUE
)
}
return(pp_all1)
}
getPara(para_name = 'theta', stan_data_fit)
temp = getPara(para_name = 'theta', stan_data_fit)
temp[1:10,1:100]
stan_data = getStanData(
beta = c('sameA', 'dist'),
deltaM_value = 9,
binary_value = NULL,
ar_value = NULL,
random_value = NULL,
deltaD_value = NULL,
option_num = 7,
format_data = format_data
)
stan_data$condition_value
# feature_data_8 = cbind(read.csv('exp2_dist_C3.csv')[,2],
#                        do.call(rbind, replicate(8, cbind(diag(7), getSameA(3)),
#                                                 simplify=FALSE)),
#                        read.csv('exp2_dist_C3.csv')[,-c(1:2)])
# colnames(feature_data_8) = c('qID',unlist(lapply(c('sameC_','sameA_','dist_'), function(x) paste0(x,1:7))))
# head(feature_data_8)
### usethis::use_data(feature_data_8, overwrite = FALSE)
temp = getData(3,'exp2','')
format_data = subset(temp$format_data, qID == 1)
stan_data = getStanData(
beta = c('sameA', 'dist'),
deltaM_value = 9,
binary_value = NULL,
ar_value = NULL,
random_value = NULL,
deltaD_value = NULL,
option_num = 7,
format_data = format_data
)
stan_fit = rstan::stan(
file = 'mm.stan',
data = stan_data,
seed = 1,
# sample_file = save_model_file,
# init = init_values,
iter = 20,
chains = 1,
warmup = 2,
cores = 1,
refresh = 100,
save_warmup = F,
init_r = 1
)
stan_data_fit = list(
stan_data = stan_data,
stan_fit = stan_fit
)
temp = getPara(para_name = 'theta', stan_data_fit)
temp[1:10,1:100]
temp[1:10,paste0('theta.',1:7,7)]
temp[1:10,paste0('theta.',1:7,'.',7)]
temp[1:10,paste0('theta.',1:7,'.',127)]
temp[1:10,paste0('theta.',1:7,'.',939)]
temp[1:10,paste0('theta.',1:7,'.',946)]
pkgbuild::compile_dll(force = TRUE)
roxygen2::roxygenise(clean = TRUE)
devtools::install(quick = FALSE) ##MUST BE FALSE THE FIRST TIME
require(devtools)
pkgbuild::compile_dll(force = TRUE)
roxygen2::roxygenise(clean = TRUE)
devtools::install(quick = FALSE) ##MUST BE FALSE THE FIRST TIME
require(devtools)
pkgbuild::compile_dll(force = TRUE)
roxygen2::roxygenise(clean = TRUE)
devtools::install(quick = FALSE) ##MUST BE FALSE THE FIRST TIME
